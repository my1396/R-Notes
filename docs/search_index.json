[["8-stata.html", "Chapter 8 Stata", " Chapter 8 Stata Resources: User Guide: https://www.stata.com/manuals/u.pdf Tutorial: https://grodri.github.io/stata/ Quick start: https://lanekenworthy.net/stata-quick-guide/ help &lt;cmd_name&gt;: Get help for a command. Keyboard Shortcut Description ctrl + R last cmd ctrl + B next cmd cmd + shift + D Run a Do file User interface Within the Stata interface window, there are five windows: Command, Results, History, Properties, and Variables While Stata can be command-driven by typing code in the Command window, it can also be used in a point-and-click manner using the menu bar. While nearly everything in Stata can be done via the menus, you’re better off typing commands into a word processing file and saving them, then copying-and-pasting them into the Stata “Command” window. Buttons Log: Track and save output from the Results window. Ensures replicability. New Do-file Editor: Organize your history commands in one place, making debugging easier. You can use do-files to create a batchlike environment in which you place all the commands you want to perform in a file and then instruct Stata to do that file. Ex. You have a do file myjob.do, you can run do myjob all commands in the do file would be sourced. Do-file It is recommended to run do files as a whole. (This is different than R.) You cannot re-run commands freely in Stata. For example, if you run a command that creates a variable x, realize you made a mistake, and then fix it, you can’t simply select the command that creates x and run it again because x already exists. You could manually drop the existing version of x, but now you’re doing things in a non-reproducible way. Running the entire do file will eliminate this problem because it reloads the data from disk every time. If you find yourself getting confused by these kinds of issues, run the entire do file rather than a selection. Do-file Rule of Thumb Your .do file begins with loading a dataset and ends with saving one. use ..., clear // begin /* your code */ save ..., replace // end Never modify the raw data files. Save the results of your data cleaning in a new file. Every data file is created by a script. Convert your interactive data cleaning session to a .do file. No data file is modified by multiple scripts. Intermediate steps are saved in different files (or kept in temporary files) than the final dataset. Keep do files short Our suggestion is that you keep your do files short enough that when you’re working on one of them you can easily wrap your head around it. You also want to keep do files short so they run as quickly as possible: working on a do file usually requires running it repeatedly, so moving any code that you consider “done” to a different do file will save time. You can have a master do file which loads your small section do files sequentially and all in one. log file log files put everything that your do file put in the Results window. Comments // for single line comment /* */ for multiple line comment //# or **# add a bookmark Continuation lines: /// Everything after /// to the end of the current line is considered a comment. The next line joins with the current line. Therefore, /// allows you to split long lines across multiple lines in the do-file. Summary of ways to break long lines: You can change the end-of-line delimiter to ; by using #delimit, #delimit ; // change the line delimiter to semicolon summarize weight price displ headroom rep78 length turn gear_ratio if substr(company,1,4)==&quot;Ford&quot; | substr(company,1,2)==&quot;GM&quot;, detail ; gen byte ford = substr(company,1,4)==&quot;Ford&quot; ; #delimit cr // change the delimiter back to carriage return gen byte gm = substr(company,1,2)==&quot;GM&quot; Once you declear #delimit ;, all lines must end in ;. Stata treats carriage returns as no different from blanks. you can comment out the line break by using /* */ comment delimiters, or you can use the /// line-join indicator. cd \"directory_name\" change working directory. don’t need quotation if there is no space need quotation if the directory has spaces pwd displays the path of the current working directory. exit, clear to quit Stata. If the dataset in memory has changed since the last time it was saved, Stata will refuse to quit unless you specify clear. Abbreviation rules: Stata allows abbreviations. You can abbreviate commands, variable names, and options. // full command . summarize myvar, detail // use abbr. to achieve the same function . sum myv, d As a general rule, command, option, and variable names may be abbreviated to the shortest string of characters that uniquely identifies them. When you read the Stata manual, it uses underlines to denote the minimal abbreviation for a command or option. E.g. When you see append, it means you can use ap to denote append. describe means the shortest allowable abbreviation for describe is desc. If there is no underlining, no abbreviation is allowed. rename can be abbreviated ren, rena, renam, or it can be spelled out in its entirety. "],["8.1-baisc-syntax.html", "8.1 Baisc syntax", " 8.1 Baisc syntax ssc install pkgname: Install pkgname from ssc. The SSC (Statistical Software Components) is the premier Stata download site. Stata is case-sensitive: myvar, Myvar and MYVAR are three distinct names. [by varlist:] command [ varlist ] [=exp] [if exp] [in range] [ weight ] [, options] where square brackets distinguish optional qualifiers and options from required ones. In this diagram, varlist denotes a list of variable names, If no varlist appears, most commands assumes _all, which indicate all the variables in the dataset. command denotes a Stata command, exp denotes an algebraic expression, range denotes an observation range, weight denotes a weighting expression, and options denotes a list of options. Note the comma , which separate the command’s main body to options. by varlist repeat a cmd for each subset of the data, grouped by varlist. Ex: group by region and summarize marriage divorce sysuse census sort region by region: summarize marriage divorce Note that your have to sort before by varlist. Alternatively, you can by region, sort: summarize marriage_rate divorce_rate if exp filter observations for which exp returns true summarize marriage_rate divorce_rate if region == &quot;West&quot; &amp; (and) and | (or) to join conditions. in range restricts the scope of the cmd to be applied to a specific observation range. First observation can be denoted by f Last observation can be denoted by l Negative numbers mean “from the end of the data” // summarize for observations 5 to 25 summarize marriage_rate divorce_rate in 5/25 // summarize for the last five observations summarize marriage_rate divorce_rate in -5/l Create new variables gen variable = expression // generate new variables replace variable = expression // replace the value of existing variables generate newvar = oldvar + 2 generate a new variable newvar, which equals oldvar+2 egen creates a new variable based on existing variables. // Generate newv1 for distinct groups of v1 and v2, and create and apply value label mylabel egen newv1 = group(v1 v2), label(mylabel) encode var, gen(newvar) creates a new variable named newvar based on the string variable varname. It alphabetizes unique values in var and assigns numeric codes to each entry. encode sex, gen(gender) // nolabel drops value labels and show how the data really appear list sex gender in 1/4, nolabel // you won&#39;t see difference using the following cmd list sex gender in 1/4 sex is a string variable and takes on values female and male. encode creates a new variable gender, mapping each level in sex to a numerical value. female becomes 1 and male becomes 2. 8.1.1 Factor Variables i.varname create indicators for each level of the variable // group=1 as base level list group i.group in 1/5 // group=3 as base level list group i3.group in 1/5 // individual fixed effects regress y i.group c.varname treat as continuous # cross, create an interaction for each combination of the variables ## factorial cross, a full factorial of the variables: standalone effects for each variable and an interaction group##sex // equivalently i.group i.sex i.group#i.sex o.varname omit a variable or indicator o.age means that the continuous variable age should be omitted, and o2.group means that the indicator for group = 2 should be omitted. 8.1.2 Time series varlists Three time series operators: L., D. and S.. First convert variables to time variables by using tsset, then you can use the TS operators. tsset time list L.gnp Convert to panel tsset country year // or xtset country year TS Operator Meaning L. lag \\(x_{t-1}\\) L2. 2-period lag \\(x_{t-2}\\) L(1/2). a varlist \\(x_{t-1}\\) and \\(x_{t-2}\\) F. lead \\(x_{t+1}\\) F2. 2-period lead \\(x_{t+2}\\) D. difference \\(x_{t}-x_{t-1}\\) D2. difference of difference \\((x_{t}-x_{t-1})-(x_{t-1}-x_{t-2})\\) S. “seasonal” difference \\(x_{t}-x_{t-1}\\) S2. lag-2 seasonal difference \\(x_{t}-x_{t-2}\\) Note that D1. = S1., but D2. \\(\\ne\\) S2.. D2. refers to the difference of difference S2. refers to the two-period difference Operators may be typed in uppercase or lowercase L(1/3).(gnp cpi) // equivalently L.gnp L2.gnp L3.gnp L.cpi L2.cpi L3.cpi DS12.gnp one-period difference of the 12-period difference .do is a Stata do-file. .dta is Stata dataset file format 8.1.3 Labels Variable labels convey information about a variable, and can be a substitute for long variable names. // generally label variable variable_name &quot;variable label&quot; // use example label variable price &quot;Price in 1978 Dollars&quot; Value labels are used with categorical variables to tell you what the categories mean. First define a mapping // generally label define map_name value1 &quot;label1&quot; value2 &quot;label2&quot;... // use example label define rep_label 1 &quot;Bad&quot; 2 &quot;Average&quot; 3 &quot;Good&quot; Add value labels to existing variables // generally label values map_name // use example label values rep3 rep_label "],["8.2-data-manipulation.html", "8.2 Data Manipulation", " 8.2 Data Manipulation 8.2.1 Import and Export Shipped datasets Stata contains some demonstration datasets in the system directories. sysuse dir: list the names of shipped datasets. sysuse lifeexp: use lifeexp Note that use lifeexp will return error. Data not found. User datasets .dta use myauto [, clear]: Load myauto.dta (Stata-format) into memory. clear it is okay to replace the data in memory, even though the current data have not been saved to disk. save myauto [, replace]: Create a Stata data type file myauto.dta replace allows Stata to overwrite existing dataset that is the output from previous attempts to run the do file. .csv import delimited myauto.csv: Import myauto.csv to Stata’s memory export delimited myauto.csv” Export to myauto.csv import delimited filename reads text (ASCII) files in which there is one observation per line and the values are separated by commas, tabs, or some other delimiter. By default, Stat will check if the file is delimited by tabs or commas based on the first line of data. export delimited filename writes data into a file in comma-separated (.csv) format by default. You can specify any separation character delimiter that you prefer. If filename is specified without an extension, .csv is assumed. If filename contains embedded spaces, enclose it in double quotes. import delimited [using] filename [, import_delimited_options] Options delimiters(\"chars\"[, collapse | asstring] ): \"chars\" specifies the delimiter \";\": uses semicolon as a delimiter; \"\\t\" uses tab, \"whitespace\" uses whitespace collapse treat multiple consecutive delimiters as just one delimiter. asstring treat chars as one delimiter. By default, each character in chars is treated as an individual delimiter. // use example import delimited auto, delim(&quot; &quot;, collapse) colrange(:3) rowrange(8) clear replace data in memory 8.2.2 Save Estimation Results estimates store model_name stores the current (active) estimation results under the name model_name. // Store estimation results as m1 for use later in the same session estimates store m1 estimates table organizes estimation results from one or more models in a single formatted table. If you type estimates table without arguments, a table of the most recent estimation results will be shown. // Display a table of coefficients for stored estimates m1 and m2 estimates table m1 m2 // with SE estimates table m1 m2, se // with sample size, adjusted 𝑅2, and stars estimates table m1 m2, stats(N r2_a) star estimate save filename save the current active estimation results to filename.ster. etable etable allows you to easily create a table of estimation results and export it to a variety of file types, e.g., docx, html, pdf, xlsx, tex, txt, markdown, md. // use example of etable . clear all . webuse nhanes2l (Second National Health and Nutrition Examination Survey) . quietly regress bpsystol age weight i.region . estimates store model1 . quietly regress bpsystol i.sex weight i.agegrp . estimates store model2 . quietly regress bpsystol age weight i.agegrp . estimates store model3 . etable, estimates(model1 model2 model3) showstars showstarsnote title(&quot;Table 1. Models for systolic blood pressure&quot;) export(mydoc.docx, replace) Options: export allows you to specify the output format 8.2.3 Stored Results Stata commands that report results also store the results where they can be subsequently used by other commands or programs. This is documented in the Stored results section of the particular command in the reference manuals. e-class commands, such as regress, store their results in e(); e-class commands are Stata’s model estimation commands. r-class commands, such as summarize, store their results in r(); most commands are r-class. // for r-class command return list // for e-class command ereturn list "],["8.3-panel.html", "8.3 Panel", " 8.3 Panel Declear panel data You must xtset your data before you can use other xt commands. xtset panelvar timevar declares the data to be a panel in which the order of observations is relevant. When you specify timevar, you can then use time series operators (e.g., L, D). Menu Statistics &gt; Longitudinal/panel data &gt; Setup and utilities &gt; Declare dataset to be panel data panelvar panel variable that identifies the unit timevar optional time variable that identifies the time within panels Use describe to show an overview of data structure. Sometimes numbers will get recorded as string variables, making it impossible to do almost any command. destring [varlist], {gen(newvarlist) | replace} [options] gen(newvarlist) generate new variables for each variable in varlist. replace replace string variables with numeric variables ignore(\"chars\") specifies nonnumeric characters be removed. // from logd_gdp to rad, convert to numeric, replace &quot;NA&quot; with missing destring logd_gdp-rad, replace ignore(`&quot;NA&quot;&#39;) xtreg is Stata’s feature for fitting linear models for panel data. xtreg, fe estimates the parameters of fixed-effects models: xtreg depvar [indepvars] [if] [in] [weight] , fe [FE_options] Menu: Statistics &gt; Longitudinal/panel data &gt; Linear models &gt; Linear regression (FE, RE, PA, BE, CRE) Options vce(robust) use clustered variance that allows for intragroup correlation within groups. By defualt, SE uses OLS estimates. "],["8.4-arellano-bond-estimator.html", "8.4 Arellano-Bond Estimator", " 8.4 Arellano-Bond Estimator The Arellano–Bond estimator is for datasets with many panels and few periods. (Technically, the large-sample properties are derived with the number of panels going to infinity and the number of periods held fixed.) The number of instruments increases quadratically in the number of periods. If your dataset is better described by a framework in which both the number of panels and the number of periods is large, then you should consider other estimators such as xtiveg or xtreg, fe. The Arellano-Bond estimator may be obtained in Stata using either the xtabond or xtdpd command. xtabond fits a linear dynamic panel-data model where the unobserved unit-level effects are correlated with the lags of the dependent variable, known as the Arellano–Bond estimator. This estimator is designed for datasets with many panels and few periods, and it requires that there be no autocorrelation in the idiosyncratic errors. xtabond uses moment conditions in which lags of the dependent variable and first differences of the exogenous variables are instruments for the first-differenced equation. xtabond depvar [ indepvars ] [ if ] [ in ] [, options ] Options: lags(#): #lags of dependent variable as covariates; default is lags(1) maxldep(#): maximum lags of dependent variable for use as instruments maxlags(#): maximum lags of predetermined and endogenous variables for use as instruments twostep: compute the two-step estimator instead of the one-step estimator pre(varlist): predetermined variables; can be specified more than once endogenous(varlist): endogenous variables; can be specified more than once vce(vcetype) vce(gmm) the default, uses the conventionally derived variance estimator for generalized method of moments estimation. vce(robust): uses the robust estimator. After one-step estimation, this is the Arellano–Bond robust VCE estimator. After two-step estimation, this is the Windmeijer (2005) WC-robust estimator. \\[ \\begin{equation} \\tag{8.1} \\begin{split} n_{i,t} &amp;= \\alpha_1 n_{i,t-1} + \\alpha_2 n_{i,t-2} + \\bbeta&#39;(L) \\bx_{it} + \\lambda_t + \\eta_i + \\varepsilon_{i,t} \\\\ &amp;= \\alpha_1 n_{i,t-1} + \\alpha_2 n_{i,t-2} \\\\ &amp;\\phantom{=}\\quad + \\beta_1 w_{i,t} + \\beta_2 w_{i,t-1} \\\\ &amp;\\phantom{=}\\quad + \\beta_3 k_{i,t} + \\beta_4 k_{i,t-1} + \\beta_5 k_{i,t-2} \\\\ &amp;\\phantom{=}\\quad + \\beta_6 ys_{i,t} + \\beta_7 ys_{i,t-1} + \\beta_8 ys_{i,t-2} \\\\ &amp;\\phantom{=}\\quad + \\gamma_3 d_3 + \\dots + \\gamma_T d_T + \\eta_i + \\varepsilon_{i,t}, \\end{split} \\end{equation} \\] where \\(i=1,\\ldots,n\\) denotes the firm, and \\(t=3,\\ldots,T\\) is the time series dimension. \\(n_{i,t}\\) is the natural logarithm of employment \\(w\\) refers to the natural logarithm of wage \\(k\\) is the natural logarithm of capital \\(ys\\) is the natural logarithm of output Variables \\(d_3,\\ldots,d_T\\) are time dummies with corresponding coefficients \\(\\gamma_3,\\ldots,\\gamma_T.\\) \\(\\eta_i\\) is the unobserved individual-specific effects. \\(\\varepsilon_{i,t}\\) is an idiosyncratic remainder component. Model (8.1) can be implemented using the following command. // Use example use https://www.stata-press.com/data/r19/abdata xtabond n l(0/1).w l(0/2).(k ys) yr1980-yr1984 year, lags(2) vce(robust) noconstant The output would look like the following. Arellano–Bond dynamic panel-data estimation Number of obs = 611 Group variable: id Number of groups = 140 Time variable: year Obs per group: min = 4 avg = 4.364286 max = 6 Number of instruments = 40 Wald chi2(13) = 1318.68 Prob &gt; chi2 = 0.0000 One-step results (Std. err. adjusted for clustering on id) Robust n Coefficient std. err. z P&gt;|z| [95% conf. interval] n L1. .6286618 .1161942 5.41 0.000 .4009254 .8563983 w --. -.5104249 .1904292 -2.68 0.007 -.8836592 -.1371906 L1. .2891446 .140946 2.05 0.040 .0128954 .5653937 L2. -.0443653 .0768135 -0.58 0.564 -.194917 .1061865 k --. .3556923 .0603274 5.90 0.000 .2374528 .4739318 L1. -.0457102 .0699732 -0.65 0.514 -.1828552 .0914348 L2. -.0619721 .0328589 -1.89 0.059 -.1263743 .0024301 yr1980 -.0282422 .0166363 -1.70 0.090 -.0608488 .0043643 yr1981 -.0694052 .028961 -2.40 0.017 -.1261677 -.0126426 yr1982 -.0523678 .0423433 -1.24 0.216 -.1353591 .0306235 yr1983 -.0256599 .0533747 -0.48 0.631 -.1302723 .0789525 yr1984 -.0093229 .0696241 -0.13 0.893 -.1457837 .1271379 year .0019575 .0119481 0.16 0.870 -.0214604 .0253754 Instruments for differenced equation GMM-type: L(2/.).n Standard: D.w LD.w L2D.w D.k LD.k L2D.k D.yr1980 D.yr1981 D.yr1982 D.yr1983 D.yr1984 D.year Instruments for level equation Standard: _cons xtdpdsys implements the Arellano–Bover/Blundell–Bond system estimator, which includes the lagged differences of n (the dependent variable) as instruments for the level equation. Test for Autocorrelation The moment conditions of these GMM estimators are valid only if there is no serial correlation in the idiosyncratic errors. Because the first difference of white noise is necessarily autocorrelated, we need only concern ourselves with second and higher autocorrelation. We can use estat abond to test for autocorrelation: . estat abond, artests(4) Arellano–Bond test for zero autocorrelation in first-differenced errors H0: No autocorrelation Order z Prob &gt; z 1 -4.6414 0.0000 2 -1.0572 0.2904 3 -.19492 0.8455 4 .04472 0.9643 Test for Overidentifying Restrictions estat sargan reports the Sargan test of overidentifying restrictions. . estat sargan Sargan test of overidentifying restrictions H0: Overidentifying restrictions are valid chi2(25) = 65.81806 Prob &gt; chi2 = 0.0000 Predetermined Covariates Sometimes we cannot assume strict exogeneity. Recall that a variable, \\(x_{it}\\), is said to be strictly exogenous if \\(\\E[𝑥_{it}\\varepsilon_{is}] = 0\\) for all \\(t\\) and \\(s\\). If \\(\\E[x_{it}\\varepsilon_{is}] \\ne 0\\) for \\(s &lt; t\\) but \\(\\E[x_{it}\\varepsilon_{is}] = 0\\) for all \\(s\\ge t,\\) the variable is said to be predetermined. Intuitively, if the error term at time \\(t\\) has some feedback on the subsequent realizations of \\(x_{it},\\) \\(x_{it}\\) is a predetermined variable. Because unforecastable errors today might affect future changes in the real wage and in the capital stock, we might suspect that the log of the real product wage and the log of the gross capital stock are predetermined instead of strictly exogenous. Here we treat \\(w\\) and \\(k\\) as predetermined and use lagged levels as instruments. xtabond n l(0/1).ys yr1980-yr1984 year, lags(2) twostep pre(w, lag(1,.)) pre(k, lag(2,.)) noconstant vce(robust) We are now including GMM-type instruments from the first lag of L.w on back and from the first lag of L2.k on back. pre(w, lag(1, .)) to mean that L.w is a predetermined variable and pre(k, lag(2, .)) to mean that L2.k is a predetermined variable. Endogenous Covariates We might instead suspect that \\(w\\) and \\(k\\) are endogenous in that \\(\\E[x_{it}\\varepsilon_{is}] \\ne 0\\) for \\(s \\le t\\) but \\(\\E[x_{it}\\varepsilon_{is}] = 0\\) for all \\(s &gt; t.\\) By this definition, endogenous variables differ from predetermined variables only in that the endogenous variables allow for correlation between \\(x_{it}\\) and \\(\\varepsilon_{it}\\) at time \\(t,\\) whereas Endogenous variables are treated similarly to the lagged dependent variable. Levels of the endogenous variables lagged two or more periods can serve as instruments. predetermined variables do NOT allow for contemparaneous correlation. In this example, we treat \\(w\\) and \\(k\\) as endogenous variables. xtabond n l(0/1).ys yr1980-yr1984 year, lags(2) twostep endogenous(w, lag(1,.)) endogenous(k, lag(2,.)) noconstant vce(robust) Although some estimated coefficients changed in magnitude, none changed in sign, and these results are similar to those obtained by treating \\(w\\) and \\(k\\) as predetermined. "]]
