[["11-stata.html", "Chapter 11 Stata", " Chapter 11 Stata Resources: User Guide: https://www.stata.com/manuals/u.pdf Tutorial: https://grodri.github.io/stata/ Quick start: https://lanekenworthy.net/stata-quick-guide/ [GSM] Getting Started with Stata for Mac help &lt;cmd_name&gt;: Get help for a command in Stata console. Overview of Documentation: [U] User‚Äôs Guide: is divided into three sections: Stata basics, Elements of Stata, and Advice. Recommended to read. Base Reference Manual: list commands alphabetically. Not designed to be read from cover to cover. The PDF documentation may be accessed from within Stata. help command_name and then click on the ‚ÄúView complete PDF manual entry‚Äù button under the command. Or in the menu bar, Help &gt; PDF Documentation to open the complete PDF documentation. The pdf documentation uses Acrobat Reader as the viewer. Tip: use finger pinch to zoom in and out. When using the zoom button or cmd +/cmd -, the text jumps around, you lose your original position. Keyboard Shortcuts Actually not of much use. Keyboard Shortcut Description ctrl + R last cmd ctrl + B next cmd cmd + shift + D Run a Do file User interface Within the Stata interface window, there are five windows: Command, Results, History, Properties, and Variables. Output appears in the Results window. E.g., . sysuse auto, clear (1978 Automobile Data) The dot (.) indicates that the current line is a Stata command. &gt; indicates that the command is not yet complete. You will see this when you have a command that spans multiple lines. While Stata can be command-driven by typing code in the Command window, it can also be used in a point-and-click manner using the menu bar. While nearly everything in Stata can be done via the menus, you‚Äôre better off typing commands into a word processing file and saving them, then copying-and-pasting them into the Stata ‚ÄúCommand‚Äù window. Buttons Log: Track and save output from the Results window. Ensures replicability. New Do-file Editor: Organize your history commands in one place, making debugging easier. You can use do-files to create a batchlike environment in which you place all the commands you want to perform in a file and then instruct Stata to do that file. Ex. You have a do file myjob.do, you can run do myjob all commands in the do file would be sourced. Do-file It is recommended to run do files as a whole. (This is different than R.) You cannot re-run commands freely in Stata. For example, if you run a command that creates a variable x, realize you made a mistake, and then fix it, you can‚Äôt simply select the command that creates x and run it again because x already exists. You could manually drop the existing version of x, but now you‚Äôre doing things in a non-reproducible way. Running the entire do file will eliminate this problem because it reloads the data from disk every time. If you find yourself getting confused by these kinds of issues, run the entire do file rather than a selection. Do-file Rule of Thumb Your .do file begins with loading a dataset and ends with saving one. use ..., clear // begin /* your code */ save ..., replace // end Never modify the raw data files. Save the results of your data cleaning in a new file. Every data file is created by a script. Convert your interactive data cleaning session to a .do file. No data file is modified by multiple scripts. Intermediate steps are saved in different files (or kept in temporary files). Keep do files short Our suggestion is that you keep your do files short enough that when you‚Äôre working on one of them you can easily wrap your head around it. You also want to keep do files short so they run as quickly as possible: working on a do file usually requires running it repeatedly, so moving any code that you consider ‚Äúdone‚Äù to a different do file will save time. Project Structure You can have a master do file which loads your small section do files sequentially and all in one. Enumerate your do files. Example: 0-master.do, 1-data-clean.do, 2-stylized-facts.do, ‚Ä¶ You can then organize them in sub-do-files: if you have different set of stylized facts, you could have: 2.1-stylized-facts-geography.do, 2.2-stylized-facts-count.do etc. . . . log file log files put everything that your do file put in the Results window. Comments // for single line comment; rest-of-line comment; it can be put at any place. Commonly used after a command to denote comments on that line. * for single line comments; the comment line must begin with *; /* */ for multiple line comment; enclosed comment; //# or **# add a bookmark /// line-join indicator Note that the // comment indicator and the /// indicator must be preceded by one or more blanks. See [U] 16.1.2 Comments and blank lines in do-files for more details. Continuation lines: /// /// is called the line-join indicator or line continuation marker. It makes long lines more readable. Everything after /// to the end of the current line is considered a comment. The next line joins with the current line. Therefore, /// allows you to split long lines across multiple lines in the do-file. Summary of ways to break long lines: You can change the end-of-line delimiter to ; by using #delimit, #delimit ; // change the line delimiter to semicolon summarize weight price displ headroom rep78 length turn gear_ratio if substr(company,1,4)==&quot;Ford&quot; | substr(company,1,2)==&quot;GM&quot;, detail ; gen byte ford = substr(company,1,4)==&quot;Ford&quot; ; #delimit cr // change the delimiter back to carriage return gen byte gm = substr(company,1,2)==&quot;GM&quot; Once you declear #delimit ;, all lines must end in ;. Stata treats carriage returns as no different from blanks. you can comment out the line break by using /* */ comment delimiters, or you can use the /// line-join indicator. Example replace final_result = /// sqrt(first_side^2 + second_side^2) /// if type == &quot;rectangle&quot; equivalently, you can use /* */ to break long lines: replace final_result = /* */ sqrt(first_side^2 + second_side^2) /* */ if type == &quot;rectangle&quot; N.B. There‚Äôs NO line continuation marker (///) in the command window. In the command window, the enter key sends what has been written on the line to Stata. There is no way to continue a long command on a second line, without sending the first (incomplete) line to Stata. You can add comments after ///. args a /// input parameter for a b /// input parameter for b c // input parameter for c is equivalent to args a b c cd \"directory_name\" change working directory. don‚Äôt need quotation if there is no space need quotation if the directory has spaces pwd displays the path of the current working directory. exit, clear to quit Stata. If the dataset in memory has changed since the last time it was saved, Stata will refuse to quit unless you specify clear. Abbreviation rules: Stata allows abbreviations. You can abbreviate commands, variable names, and options. // full command . summarize myvar, detail // use abbr. to achieve the same function . sum myv, d As a general rule, command, option, and variable names may be abbreviated to the shortest string of characters that uniquely identifies them. When you read the Stata manual, it uses underlines to denote the minimal abbreviation for a command or option. E.g. When you see append, it means you can use ap to denote append. describe means the shortest allowable abbreviation for describe is desc. If there is no underlining, no abbreviation is allowed. rename can be abbreviated ren, rena, renam, or it can be spelled out in its entirety. Open do files in tabs rather than in separate windows: https://www.reddit.com/r/stata/comments/1ivjegr/stata_18_mac_does_not_do_tabs_for_dofile_editor/ "],["11.1-basic-syntax.html", "11.1 Basic syntax", " 11.1 Basic syntax 11.1.1 Package management Users can add new features to Stata, and some users choose to make new features that they have written available to others via the web. The files that comprise a new feature are called a package, and a package usually consists of one or more ado-files and help files. ssc install newpkgname: Install newpkgname from ssc. The SSC (Statistical Software Components) is the premier Stata download site. ssc uninstall pkgname to uninstall pkgname ado update to update packages ssc hot [, n(#)] a list of most popular pkgs at SSC. n(#) to specify the number of pkgs listed. Stata is case-sensitive: myvar, Myvar and MYVAR are three distinct names. Semicolons (:) is treated as a line separator. It is not required, but it may be used to place two statements on the same physical line: x = 1 ; y = 2 ; The last semicolon in the above example is unnecessary but allowed. 11.1.2 Types and Declarations A variable‚Äôs type can be described in two perspectives: eltype: specifies the type of the elements. Default: transmorphic. orgtype: specifies the organization of the elements. Default: matrix. eltype orgtype transmorphic matrix numeric vector real rowvector complex colvector string scalar pointer [by varlist:] command [ varlist ] [=exp] [if exp] [in range] [ weight ] [, options] where square brackets distinguish optional qualifiers and options from required ones. In this diagram, varlist denotes a list of variable names. Variables are separated by spaces. Use help varlist for more details on how to specify varlist. If no varlist appears, most commands assumes _all, which indicate all the variables in the dataset. command denotes a Stata command, exp denotes an algebraic expression, range denotes an observation range, weight denotes a weighting expression, and options denotes a list of options. Note the comma , which separate the command‚Äôs main body from options. by varlist repeat a cmd for each subset of the data, grouped by varlist. Ex: group by region and summarize marriage divorce sysuse census sort region by region: summarize marriage divorce Note that your have to sort before by varlist. Alternatively, you can by region, sort: summarize marriage_rate divorce_rate if exp filter observations for which exp returns true summarize marriage_rate divorce_rate if region == &quot;West&quot; &amp; (and) and | (or) to join conditions. in range restricts the scope of the cmd to be applied to a specific observation range. First observation can be denoted by f Last observation can be denoted by l Negative numbers mean ‚Äúfrom the end of the data‚Äù // summarize for observations 5 to 25 summarize marriage_rate divorce_rate in 5/25 // summarize for the last five observations summarize marriage_rate divorce_rate in -5/l 11.1.3 Create new variables gen variable = expression // generate new variables replace variable = expression // replace the value of existing variables generate create variables based on expressions you specified. generate newvar = oldvar + 2 generate a new variable newvar, which equals oldvar + 2 generate lngdp = ln(gdp) generate the natural log of gdp generate exp2 = exp^2 generate the square of exp egen: Extensions to generate; creates a new variable based on egen functions of existing variables. Q: What are egen functions? A: The functions are specifically written for egen. // Generate newv1 for distinct groups of v1 and v2, and create and apply value label mylabel egen newv1 = group(v1 v2), label(mylabel) // for each country, calculate the average of wpop by country_id, sort: egen pop_country = mean(wpop) gen vs.¬†egen gen used for simple algebraic transformations egen for more complexed transformations, e.g., operations based on groups of observations. They behave differently if you want to calcualte the sum per group. gen returns running sum egen returns group sum // Create variable containing the running sum of x generate runsum = sum(x) // Create variable containing a constant equal to the overall sum of x egen totalsum = total(x) encode var, gen(newvar) creates a new variable named newvar based on the string variable varname. It alphabetizes unique values in var and assigns numeric codes to each entry. encode sex, gen(gender) // nolabel drops value labels and show how the data really appear list sex gender in 1/4, nolabel // you won&#39;t see difference using the following cmd list sex gender in 1/4 sex is a string variable and takes on values female and male. encode creates a new variable gender, mapping each level in sex to a numerical value. female becomes 1 and male becomes 2. display displays strings and values of scalar expressions. display [display_directive [display_directive [...]]] list displays the values of variables. If no varlist is specified, the values of all the variables are displayed. list [varlist] [if] [in] [, options] 11.1.4 Refer to a range of variables How can I list, drop, and keep a consecutive set of variables without typing the names individually? list all variables starting with a certain prefix list all variables between two variables combination of the two // list all variables starting with a certain prefix . list var* // all variables starting with &quot;var&quot; // list all variables between two variables . list var1-var5 // all variables between var1 and var5 // combination of the two . list var1 var3-var5 Wildcard characters: * matches any string of characters, including no characters. ? matches any single character. ?* matches one or more character ??* matches two or more characters var1-var2 specifies a range of variables, from the first variable to the second variable, in the order in which they appear in the dataset. A numlist is a list of numbers. It can include individual numbers, ranges of numbers, and increments. Common operators in numlist: range: start/end means all numbers from start to end, inclusive. start to end start:end specify increment start(increment)end or start[increment]end Ex 1/3 // 1,2,3 -5/-8 // -5,-6,-7,-8 1 to 3 // 1,2,3 1(2)9 // 1,3,5,7,9 If you want to consider reordering the variables in your dataset, order, sequential will put the variables in alphabetical order (and does mostly smart things with numeric suffixes). . order *, sequential the resulting order will be: 1. alpha 2. beta 3. gamma 4. v1 5. v2 6. v3 7. v4 order, sequential is smart enough to know that v10 comes after v9 and not between v1 and v2, which pure alphabetical order would specify. For online help, type help order in Stata, or see [D] order. 11.1.5 System Variables Expressions may also contain variables (pronounced ‚Äúunderscore variables‚Äù), which are built-in system variables that are created and updated by Stata. They are called variables because their names all begin with the underscore character, _. Var Description _n the number of the current observation. _N the total number of observations in the dataset or the number of observations in the current by() group. _pi \\(\\pi\\) [eqno]_b[varname] or [eqno]_coef[varname] value of the coefficient on varname from the most recently fitted model [eqno]_se[varname] standard error of the coefficient on varname from the most recently fit model _b[_cons] value of the intercept term 11.1.6 Matrix You enter the matrices by row, separate one element from the next by using commas (,) and one row from the next by using backslashes (\\). To create \\[ A = \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{pmatrix} \\] matrix [input] a = (1,2\\3,4) matrix list a input is optional. without input, matrix must be small, can include expressions. with input, matrix can be large, but no expressions for the elements. Menu: Data &gt; Matrices, ado language &gt; Input matrix by hand Get one element using matname[r,c] to get r row, c column element. matrix rownames and colnames reset the row and column names of an already existing matrix. matrix roweq and coleq also reset the row and column names of an already existing matrix, but if a simple name (a name without a colon) is specified, it is interpreted as an equation name. // Reset row names of matrix matrix rownames A = names matrix colnames A = names // Reset row names and interpret simple names as equation names matrix roweq A = names matrix coleq A = names A is a matrix. name can be: a simple name; var an interaction; e.g., var1#var2 a colon followed by a simple name; a colon followed by an interaction; an equation name followed by a colon, and a simple name; e.g., myeq:var an equation name, a colon, and an interaction, e.g., myeq:var1#var2 Matrix define: https://www.stata.com/manuals/pmatrixdefine.pdf#pmatrixdefine Macro functions rownames A and colnames A return a list of all the row or column subnames (with time-series operators if applicable) of A, separated by single blanks. The equation names, even if present, are not included. roweq A and coleq A return a list of all the row equation names or column equation names of A, separated by single blanks, and with each name appearing however many times it appears in the matrix. rowfullnames A and colfullnames A return a list of all the row or column names, including equation names of A, separated by single blanks. 11.1.7 Factor Variables help fvvarlist for documentation on factor variables. i.varname create indicators for each level of the variable // group=1 as base level list group i.group in 1/5 // group=3 as base level list group i3.group in 1/5 // individual fixed effects regress y i.group ib#.varname specify the base level. # is the value of the base level. By default, the smallest level becomes the base level. i might be omitted. ib3.group is equivalent to b3.group. c.varname treat as continuous # cross, create an interaction for each combination of the variables. Spaces are not allowed in interactions. sex#c.age // interaction between categorical variable `sex` and continuous variable `age` c.age#c.age // age squared c.age#c.age#c.age // age cubed ## factorial cross, a full factorial of the variables: standalone effects for each variable and an interaction group##sex // equivalently i.group i.sex i.group#i.sex o.varname omit a variable or indicator o.age means that the continuous variable age should be omitted, and o2.group means that the indicator for group = 2 should be omitted. Interaction Expansion xi [ , prefix(string) noomit ] term(s) xi expands terms containing categorical variables into indicator (also called dummy) variable sets. xi provides a convenient way to include dummy or indicator variables when fitting a model that does NOT support factor variables, e.g., xtabond. We recommend that you use factor variables instead of xi if a command allows factor variables. By default, xi will create interaction variables starting with _I. This can be changed using the prefix(string) option. Operator Description i.varname creates dummies for categorical variable varname i.varname1*i.varname2 creates dummies for categorical variables varname1 and varname2: main effects and all interactions i.varname1*varname3 creates dummies for categorical variable varname1 and continuous variable varname3: main effects and all interactions i.varname1|varname3 creates dummies for categorical variable varname1 and continuous variable varname3: all interactions and main effect of varname3, but NO main effect of varname1 xi expands both numeric and string categorical variables. agegrp takes on values 1, 2,3, and 4. xi: logistic outcome i.agegrp xi tabulates i.agegrp creates indicator (dummy) variables for each observed value, omitting the indicator for the smallest value. This creates variables name -Iagegrp2, -Iagegrp3, and -Iagegrp4. // The expanded logistic model is logistic outcome _Iagegrp_2 _Iagegrp_3 _Iagegrp_4 Dummy variables are created automatically and are left in your dataset. You can drop them by typing drop I*. You do not have to do this; each time you use xi, any automatically generated dummies with the same prefix as the one specified in the prefix(string) option, or _I by default, are dropped and new ones are created. Use xi as a command prefix // simple effects xi: logistic outcome weight i.agegrp bp // interactions of categorical variables xi: logistic outcome weight bp i.agegrp*i.race // interactions of dummy variables with continuous variables // fits a model with indicator variables for all agegrp categories interacted with weight, plus the maineffect terms weight and i.agegrp. xi: logistic outcome bp i.agegrp*weight i.race // interaction terms without the agegrp main effect (but with the weight main effect) xi: logistic outcome bp i.agegrp|weight i.race 11.1.8 Time series varlists Three time series operators: L., D. and S.. Basic syntax: operator(order/spec).(varlist) First convert variables to time variables by using tsset, then you can use the TS operators. tsset time list L.gnp Convert to panel tsset country year // or xtset country year TS Operator Meaning L. lag \\(x_{t-1}\\) L2. 2-period lag \\(x_{t-2}\\) L(1/2). a varlist \\(x_{t-1}\\) and \\(x_{t-2}\\) L(2/.). from $x_{t-2} up to the maximum available lag F. lead \\(x_{t+1}\\) F2. 2-period lead \\(x_{t+2}\\) D. difference \\(x_{t}-x_{t-1}\\) D2. difference of difference \\((x_{t}-x_{t-1})-(x_{t-1}-x_{t-2})\\) S. ‚Äúseasonal‚Äù difference \\(x_{t}-x_{t-1}\\) S2. lag-2 seasonal difference \\(x_{t}-x_{t-2}\\) 2/. the dot means ‚Äúup to the maximum available lag/lead‚Äù. Note that D1. = S1., but D2. \\(\\ne\\) S2.. D2. refers to the difference of difference S2. refers to the two-period difference Operators may be typed in uppercase or lowercase L(1/3).(gnp cpi) // equivalently L.gnp L2.gnp L3.gnp L.cpi L2.cpi L3.cpi DS12.gnp one-period difference of the 12-period difference .do is a Stata do-file. .dta is Stata dataset file format 11.1.9 Labels Variable labels convey information about a variable, and can be a substitute for long variable names. // generally label variable variable_name &quot;variable label&quot; // use example label variable price &quot;Price in 1978 Dollars&quot; Value labels are used with categorical variables to tell you what the categories mean. First define a mapping // generally label define map_name value1 &quot;label1&quot; value2 &quot;label2&quot;... // use example label define rep_label 1 &quot;Bad&quot; 2 &quot;Average&quot; 3 &quot;Good&quot; Add value labels to existing variables // generally label values map_name // use example label values rep3 rep_label 11.1.10 Output format % indicates the start of a format specification. %9.2f means a floating-point number with 9 characters wide, including 2 digits after the decimal point. the first digit states the width of the results the second digit after the decimal point states the number of digits after the decimal point f for fixed format. Alternatively, e for scientific notation ref: [U] 12.5 Data: Formats, control how data are displayed "],["11.2-data-manipulation.html", "11.2 Data Manipulation", " 11.2 Data Manipulation 11.2.1 Import and Export Shipped datasets Stata contains some demonstration datasets in the system directories. sysuse dir: list the names of shipped datasets. sysuse lifeexp: use lifeexp Note that use lifeexp will return error. Data not found. User datasets .dta use myauto [, clear]: Load myauto.dta (Stata-format) into memory. clear it is okay to replace the data in memory, even though the current data have not been saved to disk. save myauto [, replace]: Create a Stata data type file myauto.dta replace allows Stata to overwrite existing dataset that is the output from previous attempts to run the do file. .csv import delimited myauto.csv: Import myauto.csv to Stata‚Äôs memory export delimited myauto.csv‚Äù Export to myauto.csv import delimited filename reads text (ASCII) files in which there is one observation per line and the values are separated by commas, tabs, or some other delimiter. By default, Stat will check if the file is delimited by tabs or commas based on the first line of data. export delimited filename writes data into a file in comma-separated (.csv) format by default. You can specify any separation character delimiter that you prefer. If filename is specified without an extension, .csv is assumed. If filename contains embedded spaces, enclose it in double quotes. import delimited [using] filename [, import_delimited_options] Options delimiters(\"chars\"[, collapse | asstring] ): \"chars\" specifies the delimiter \";\": uses semicolon as a delimiter; \"\\t\" uses tab, \"whitespace\" uses whitespace collapse treat multiple consecutive delimiters as just one delimiter. asstring treat chars as one delimiter. By default, each character in chars is treated as an individual delimiter. // use example import delimited auto, delim(&quot; &quot;, collapse) colrange(:3) rowrange(8) clear replace data in memory 11.2.2 Save Estimation Results estimates store model_name stores the current (active) estimation results under the name model_name. // Store estimation results as m1 for use later in the same session . estimates store m1 // to get them back . estimates restore m1 // Find out what you have stored . estimates dir estimate save saves the current active estimation results to a file with the extension .ster. // Save the current active estimation results . estimate save basemodel file basemodel.ster saved In a different session, you can reload those results: // Load the saved estimation results . estimates use basemodel // Display the results . estimates table Q: What is the difference between estimates store and estimates save? A: Once estimation results are stored (estimates store), you can use other estimates commands to produce tables and reports from them. estimates save saves the results to disk (as a .ster file) so that you can use them in a different Stata session. estimates store keeps the results in memory, fast and temporary. The most common use is to store results from multiple models in the same session for comparison. estimates save keeps the results on disk, persistent. The most common use is to save time-consuming important results for future reference. Also useful when you want to share results with others. estimates table [namelist] [, options] organizes estimation results from one or more models in a single formatted table. If you type estimates table without arguments, a table of the most recent estimation coefficients will be shown. estimates table namelist is useful to compare results from multiple models side by side. Good for a quick preview. Use esttab or etable for more advanced table formatting and exporting. // Display a table of coefficients for stored estimates m1 and m2 estimates table m1 m2 // with SE estimates table m1 m2, se // with sample size, adjusted ùëÖ2, and stars estimates table m1 m2, stats(N r2_a) star You can add more results to show using options: stats(scalarlist) reports additional statistics in the table. Below are commonly used result identifiers: N for sample size r2_a for adjusted \\(R^2\\) r2 for \\(R^2\\) F for F-statistic chi2 for chi-squared statistic p for p-value stats(N r2_a) to show sample size and adjusted \\(R^2\\) star shows stars for significance levels. By default, star(.05 .01 .001), which uses the following significance levels: * for \\(p &lt; 0.05\\) ** for \\(p &lt; 0.01\\) *** for \\(p &lt; 0.001\\) You can change the significance levels using star(.1 .05 .01) to set the levels to 0.10, 0.05, and 0.01, respectively. Many journals use this convention actually. Also this boost the appearance of significance even though the p-values remain the same. * for \\(p &lt; 0.10\\) ** for \\(p &lt; 0.05\\) *** for \\(p &lt; 0.01\\) N.B. the star option may NOT be combined with the se, t, or p option. An error will be returned if you try to combine them: . estimate table, star se t p star option star not allowed Parameter statistics options: b[%fmt] how to format the coefficients. se[%fmt] show standard errors and use optional format t[%fmt] show \\(t\\) or \\(z\\) statistics and use optional format p[%fmt] show \\(p\\) values and use optional format varlabel display variable labels rather than variable names // show stars for sig. levels . estimates table, star // show se, t, and p values . estimates table, se t p All statistics are shown in order under the coefficients. If you have a long list of variables, the table can be very long. You can use keep(varlist) to keep only the variables you want to show in the table. varlist is a list of variables you want to keep in the table. A list of variables can be specified as keep(var1 var2 var3). Names are separated by spaces. Not possible to use variable ranges, e.g., keep(var1-var3) will return an error. When you have multiple equations, use eqn_name:varname to specify the variable in a specific equation. Example output By default, estimates table shows only the coefficients for all regressors. Use keep() to show only selected variables, and use star to show significance levels. . estimates table global_trend country_trend, keep(L.logd_gdp tmp tmp2 pre pre2 tmp_pre tmp2_pre tmp_pre2 tmp2_pre2) star ---------------------------------------------- Variable | global_trend country_trend -------------+-------------------------------- logd_gdp | L1. | .02106535 .01196853 | tmp | .02233754** .02285209** tmp2 | -.00091508*** -.00093839*** pre | .07140978 .07469934 pre2 | -.04168053 -.04459604 tmp_pre | -.01259437 -.01284796 tmp2_pre | .00047348* .00047987* tmp_pre2 | .00472783 .00496185 tmp2_pre2 | -.00013928 -.00014426 ---------------------------------------------- Legend: * p&lt;0.05; ** p&lt;0.01; *** p&lt;0.001 Print standard errors, t-statistics, and p-values together: . estimates table global_trend country_trend, keep(L.logd_gdp tmp tmp2 pre pre2 tmp_pre tmp2_pre tmp_pre2 tmp2_pre2) &gt; se t p ---------------------------------------- Variable | global_t~d country_~d -------------+-------------------------- logd_gdp | L1. | .02106535 .01196853 | .01402981 .01433765 | 1.50 0.83 | 0.1332 0.4039 | tmp | .02233754 .02285209 | .0068979 .00701607 | 3.24 3.26 | 0.0012 0.0011 tmp2 | -.00091508 -.00093839 | .00019456 .00019787 | -4.70 -4.74 | 0.0000 0.0000 ... ... tmp_pre2 | .00472783 .00496185 | .00420448 .00427315 | 1.12 1.16 | 0.2608 0.2456 tmp2_pre2 | -.00013928 -.00014426 | .00009435 .00009588 | -1.48 -1.50 | 0.1399 0.1324 ---------------------------------------- Legend: b/se/t/p 11.2.2.1 esttab esttab [ namelist ] [ using filename ] [, options estout_options ] namelist is a list of stored estimation results to be included in the table. Can be _all. If namelist is omitted, esttab tabulates the estimation sets stored by eststo. If no such estimates exist, esttab tabulates the most recent estimation results. eststo stores a copy of the active estimation results for later tabulation. If name is provided, the estimation set is stored under name. If name is not provided, the estimation set is stored under est#, where # is a counter for the number of stored estimation sets. eststo may be used in two ways: Either after fitting a model as in . regress y x . eststo or as a prefix command: . eststo: regress y x Add name to model using eststo model_name. . sysuse auto (1978 Automobile Data) . quietly regress price weight . eststo model1 . quietly regress turn weight foreign . eststo model2 . estout -------------------------------------- model1 model2 b b -------------------------------------- weight 2.044063 .0042183 foreign -1.809802 _cons -6.707353 27.44963 -------------------------------------- Alternatively, use estimates store model_name to store estimation results. Output example of estab -------------------------------------------- (1) (2) price price -------------------------------------------- weight 1.747** 3.465*** (2.72) (5.49) mpg -49.51 21.85 (-0.57) (0.29) foreign 3673.1*** (5.37) _cons 1946.1 -5853.7 (0.54) (-1.73) -------------------------------------------- N 74 74 -------------------------------------------- t statistics in parentheses * p&lt;0.05, ** p&lt;0.01, *** p&lt;0.001 The default of esttab is to display raw point estimates along with t-statistics and to print the number of observations in the table footer. Parameter statistics options: You can replace the t-statistics with standard errors by using the se option. The t-statistics can also be replaced by p-values (option p), confidence intervals (option ci), or any parameter statistics contained in the estimates (see the aux() option). If you want to include multiple parameter statistics, you can make use of the cells() option. E.g., cells(\"b(fmt(%9.4f)) se(fmt(%9.4f) par) t(fmt(%9.2f)) p(fmt(%9.3f) star)\") will display the point estimates, standard errors, t-statistics, and p-values in the specified formats. Note that the significance star will be added to the p-values. By doing so, you can perform calculations using the coefficients. Use help estout for more details about the cells(element[(subopts)]) option. cells() specifies the contents of the table cells. For each element (b, se, t, p, etc.), you can specify suboptions in parentheses to control the format and appearance of the statistics. Available cells() subopts: fmt(%fmt) specify the format for the statistic star add significance stars nostar suppress significance stars label add a customized label instead of default abbreviation par enclose the statistic in parentheses N.B. By default, multiple statistics are stacked vertically (i.e., one statistic per line). If you want to display them side by side, enclose the elements in quotes or parentheses, e.g., cells(\"b se t p\") or cells((b se t p)). You can add suboptions to each element as needed. See the wide table below for more details. Summary statistics options: Adjusted R-squared (option ar2), pseudo R-squared (option pr2), Akaike‚Äôs or Schwarz‚Äôs information criterion (options aic and sic). Significance stars options: star(* .05 ** .01 *** .001) adds significance stars to the point estimates based on the specified p-value cutoffs. You can change the significance levels by specifying different cutoff values. For example, star(* .1 ** .05 *** .01) will use 0.1, 0.05, and 0.01 as the significance levels for one, two, and three stars, respectively. Syntax: star[(symbol level [...])] Note that the threshold levels must lie in the \\((0,1]\\) interval and must be specified in descending order. star(+ 0.10 * 0.05) will use + for \\(p&lt;.10\\) and * for \\(p&lt;.05.\\) When you change the default behavior of star, the legned is sometimes disabled. This happens when you add the stars to p-values instead of point estimates. In such cases, use legend to show the legend explaining the significance levels. When you change the significance levels, e.g., star(* 0.10 ** 0.05 *** 0.01), the legend will be updated automatically. staraux adds significance stars based on auxiliary statistics (t-stat or SE depending on your settings) instead of the point estimates. Layout options: plain setting all formats to %9.0g. This can be useful when you want to export the table to CSV. Without plain, the table cells are enclosed in double quotes and preceded by an equal sign (i.e., =\"...\"). This is to prevent Excel from interpreting the contents of the table cells. But the drawback is that you cannot perform calculations directly in Excel using these cells. To enable calculations, you can use the plain option to export the table cells enclosed in double quotes without the leading equal sign. wide causes point estimates and t-statistics (or standard errors, etc.) to be printed beside one another instead of beneath one another. (By default, esttab stacks all parameter statistics beneath the point estimates.) N.B. This only works when a single parameter statistic is displayed per model. If you have multiple statistics per model (e.g., both standard errors and t-statistics), wide will be ignored. You need to use cells() to explicitly specify the layout you want. // Each statistic as a separate column, wide format esttab dynamic_model_xtabond using &quot;data/stata/xtabond_test.csv&quot;, /// cells(&quot;b(fmt(%9.4f)) se(fmt(%9.4f)) t(fmt(%9.2f)) p(fmt(%9.3f) star)&quot;) /// keep(L.logd_gdp tmp tmp2 pre pre2 tmp_pre tmp2_pre tmp_pre2 tmp2_pre2) /// csv replace legend Note that cells(b se) will produce the vertical layout by default. To get the wide layout, two options: put elements in quotes cells(\"b se\") put elements in parentheses cells((b se)) Long table example . estout, cells(b se) -------------------------------------- est1 est2 b/se b/se -------------------------------------- weight 1.746559 3.464706 .6413538 .630749 mpg -49.51222 21.8536 86.15604 74.22114 foreign 3673.06 683.9783 _cons 1946.069 -5853.696 3597.05 3376.987 -------------------------------------- Wide table example . estout est2, cells(&quot;b se t p&quot;) ---------------------------------------------------------------- est2 b se t p ---------------------------------------------------------------- weight 3.464706 .630749 5.493003 5.99e-07 mpg 21.8536 74.22114 .2944391 .7692938 foreign 3673.06 683.9783 5.370142 9.72e-07 _cons -5853.696 3376.987 -1.733408 .0874262 ---------------------------------------------------------------- mtitles[(list)] specifies model titles to be printed as the table header. If list is omitted, the names of the stored estimation results are used as model titles. Output options: replace allows Stata to overwrite existing files. ref: https://repec.sowi.unibe.ch/stata/estout/esttab.html 11.2.2.2 etable etable allows you to easily create a table of estimation results and export it to a variety of file types, e.g., docx, html, pdf, xlsx, tex, txt, markdown, md. Easier to use than esttab for exporting a regression table; but less flexible. esttab is more customizable. // use example of etable . clear all . webuse nhanes2l (Second National Health and Nutrition Examination Survey) . quietly regress bpsystol age weight i.region . estimates store model1 . quietly regress bpsystol i.sex weight i.agegrp . estimates store model2 . quietly regress bpsystol age weight i.agegrp . estimates store model3 . etable, estimates(model1 model2 model3) showstars showstarsnote title(&quot;Table 1. Models for systolic blood pressure&quot;) export(mydoc.docx, replace) Options: showstars and showstarsnote shows stars and notes for significance levels. export allows you to specify the output format 11.2.3 Stored Results Stata commands that report results also store the results where they can be subsequently used by other commands or programs. This is documented in the Stored results section of the particular command in the reference manuals. r-class commands, such as summarize, store their results in r(); most commands are r-class. e-class commands, such as regress, store their results in e(); e-class commands are Stata‚Äôs model estimation commands. // for r-class command return list // for e-class command ereturn list Most estimation commands leave behind e(b) the coefficient vector, and e(V) the variance‚Äìcovariance matrix of the estimates (VCE) // display coef vector matrix list e(b) // assign it to a variable matrix myb = e(b) matrix list myb You can refer to e(b) and e(V) in any matrix expression: matrix c = e(b)*invsym(e(V))*e(b)‚Äô matrix list c invsym(e(V)) returns the inverse of e(V). Generally, invsym requires a a square, symmetric, and positive-definite matrix. "]]
